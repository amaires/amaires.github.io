<!DOCTYPE html> 
<html lang="en" xml:lang="en" > 
<head><title>Energy Based Models</title> 
<meta  charset="utf-8" /> 
<meta name="generator" content="TeX4ht (https://tug.org/tex4ht/)" /> 
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<link rel="stylesheet" type="text/css" href="EBM.css" /> 
<meta name="src" content="EBM.tex" /> 
</head><body 
>
   <div class="maketitle">


<h2 class="titleHead">Energy Based Models</h2>
<div class="author" ><span 
class="ecrm-1200">Amaires@June 2024</span></div><br />
<div class="date" ></div>
   </div>
   <h3 class="sectionHead"><span class="titlemark">1   </span> <a 
 id="x1-10001"></a>Motivation</h3>
<!--l. 43--><p class="noindent" >Essential to generative learning is the modeling of the probability density function (PDF) of given data. In theory, a deep neural network
<!--l. 45--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>f</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></math> is capable of approxmating
any function. <!--l. 45--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>f</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></math> in
general, however, is not a valid PDF which has two fundamental requirements:
     </p><dl class="description"><dt class="description">
<span 
class="ecbx-1000">Non-negativity:</span> </dt><dd 
class="description"><!--l. 49--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>f</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-rel">≥</mo> <mn>0</mn></math>
     </dd><dt class="description">
<span 
class="ecbx-1000">Normalization:</span> </dt><dd 
class="description"><!--l. 50--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
class="MathClass-op">∫
 <!--nolimits--></mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo><!--nolimits--><msub><mrow 
><mi 
>f</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-rel">=</mo> <mn>1</mn></math></dd></dl>
<!--l. 52--><p class="noindent" >The non-negativity requirement is not hard to satisfy with simple transformations applied to
<!--l. 53--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>f</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></math>. For
example, <!--l. 53--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi class="qopname"> exp</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>f</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo></math>
and <!--l. 54--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msubsup><mrow 
><mi 
>f</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow><mrow 
><mn>2</mn></mrow></msubsup 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math> are
both non-negative.
</p><!--l. 56--><p class="indent" >   The normalization requirement, however, is much harder to satisfy. There are a few approaches to this problem.
     </p><ol  class="enumerate1" >
     <li 
  class="enumerate" id="x1-1002x1">Generative Adversarial Network (GAN) does not model the PDF or rely on the PDF for training. Instead, it only creates a model
     that can draw samples from.
     </li>
     <li 
  class="enumerate" id="x1-1004x2">Autoregressive models break the PDF into the product of a series of conditional PDFs.
     </li>
     <li 
  class="enumerate" id="x1-1006x3">Normalizing ﬂow models use a sequence of bijective mappings to transform relatively simple distributions to the desired PDF.
     </li>
     <li 
  class="enumerate" id="x1-1008x4">Variational AutoEncoders (VAE) optimizes the upper bound of likelihoods. Like GAN, it does not produce a true PDF at the end
     either.</li></ol>
<!--l. 69--><p class="noindent" >Energy Based Models (EBM) take a diﬀerent approach. EBM only models a non-normalized function
<!--l. 70--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math> with the
expecation that the actual PDF will be </p><table class="equation-star"><tr><td>
<!--l. 72--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                       <msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
> <mo 
class="MathClass-rel">=</mo> <mfrac><mrow 
><mi class="qopname">exp</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo></mrow> 
      <mrow 
><msub><mrow 
><mi 
>Z</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></mrow></mfrac>      <mo 
class="MathClass-punc">,</mo><mspace width="0.17em" class="thinspace"/><mspace width="0.17em" class="thinspace"/><mstyle mathvariant="normal"><mi 
>w</mi><mi 
>h</mi><mi 
>e</mi><mi 
>r</mi><mi 
>e</mi></mstyle><mspace width="0.17em" class="thinspace"/><mspace width="0.17em" class="thinspace"/><msub><mrow 
><mi 
>Z</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
> <mo 
class="MathClass-rel">=</mo><mo  
> ∫
 <!--nolimits--></mo><!--nolimits--><mi class="qopname">exp</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo>
</math></td></tr></table>
<!--l. 75--><p class="indent" >   <!--l. 75--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>Z</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></math>, the normalization
numerator and a function of <!--l. 75--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>𝜃</mi></math>
but not <!--l. 76--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math> , is
also called the <span 
class="ecti-1000">partition function</span>. EBM has some of its roots in statistical physics and hence the name Energy Based Models.
<!--l. 78--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math>, or in
literature <!--l. 78--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-bin">−</mo> <msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math>,
is called the <span 
class="ecti-1000">energy function</span>. Without the normalization requirement, and unlike autoregressive models and normalizing ﬂow models, EBM can give
<!--l. 81--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></math> more
ﬂexibity and potentially make it more powerful.
</p><!--l. 84--><p class="indent" >   Since EBM only explicitly model <!--l. 84--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></math>,
but not <!--l. 84--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>Z</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></math> or
<!--l. 85--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></math>, so any task that strictly
requires <!--l. 85--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></math> is out of the
question. <!--l. 86--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></math>, however, is
suﬃcient for comparing <!--l. 87--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>x</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
><mo 
class="MathClass-close">)</mo></math>
and <!--l. 87--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>x</mi></mrow><mrow 
><mn>2</mn></mrow></msub 
><mo 
class="MathClass-close">)</mo></math> since </p><table class="equation"><tr><td>
<a 
 id="x1-1009r1"></a>
<!--l. 88--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                               <msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>x</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-rel">&#x003E;</mo> <msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>x</mi></mrow><mrow 
><mn>2</mn></mrow></msub 
><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-rel">⇔</mo><mi class="qopname">exp</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>x</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-rel">&#x003E;</mo><mi class="qopname"> exp</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>x</mi></mrow><mrow 
><mn>2</mn></mrow></msub 
><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-rel">⇔</mo><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>x</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-rel">&#x003E;</mo> <msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>x</mi></mrow><mrow 
><mn>2</mn></mrow></msub 
><mo 
class="MathClass-close">)</mo>
</math></td><td class="eq-no">(1)</td></tr></table>
<!--l. 91--><p class="indent" >   This property is enough to enable a lot of practical deep learning applications such as object recognition, paining restoration and sequence
labeling etc.
</p><!--l. 95--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">2   </span> <a 
 id="x1-20002"></a>Sampling</h3>
<!--l. 97--><p class="noindent" >Since EBMs do not explicitly model <!--l. 97--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></math>,
how are samples drawn given <!--l. 98--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></math>?
</p><!--l. 100--><p class="indent" >   The Metopolis-Hastings Markov Chain Monte Carlo (M-H MCMC) method described in Algorithm <a 
href="#x1-2001r1">1<!--tex4ht:ref: alg:mcmc --></a> is a relatively simple solution. The * step ensures that
suﬃcient space of <!--l. 102--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math>
is sampled and that the algorithm does not get stuck with local maximum. The M-H MCMC method works in theory, but can take a very long time
to converge.
</p><!--l. 107--><p class="indent" >   <a 
 id="x1-2001r1"></a></p><figure class="float" 
>
     <dl class="list1"><dt class="list">
     </dt><dd 
class="list">
     <!--l. 107--><p class="noindent" ><!--l. 108--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math><span 
class="ectt-1000">:=norm_random()</span>
     </p><!--l. 110--><p class="noindent" ><span 
class="ectt-1000">until</span><span 
class="ectt-1000"> convergence:</span>
         </p><dl class="list2"><dt class="list">
         </dt><dd 
class="list">
         <!--l. 111--><p class="noindent" ><!--l. 112--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>y</mi> <mo 
class="MathClass-punc">:</mo></math><span 
class="ectt-1000">=</span><!--l. 112--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math><span 
class="ectt-1000">+</span><!--l. 112--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>𝜖</mi><mo 
class="MathClass-bin">⋅</mo></math><span 
class="ectt-1000">norm_random()</span>
         </p><!--l. 114--><p class="noindent" ><span 
class="ectt-1000">if</span><span 
class="ectt-1000"> </span><!--l. 114--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>y</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-rel">&#x003E;</mo> <msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math><span 
class="ectt-1000">:</span>
             </p><dl class="list3"><dt class="list">
             </dt><dd 
class="list">
             <!--l. 115--><p class="noindent" ><!--l. 116--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi> <mo 
class="MathClass-punc">:</mo><mo 
class="MathClass-rel">=</mo> <mi 
>y</mi></math></p></dd></dl>
         <!--l. 118--><p class="noindent" ><span 
class="ectt-1000">else:</span>
             </p><dl class="list3"><dt class="list">
             </dt><dd 
class="list">
             <!--l. 119--><p class="noindent" ><span 
class="ectt-1000">with</span><span 
class="ectt-1000"> probability</span><span 
class="ectt-1000"> </span><!--l. 120--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi class="qopname">exp</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>y</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">−</mo> <msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo></math><span 
class="ectt-1000">:</span>
                </p><dl class="list4"><dt class="list">
                </dt><dd 
class="list">
                <!--l. 121--><p class="noindent" ><!--l. 122--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi> <mo 
class="MathClass-punc">:</mo><mo 
class="MathClass-rel">=</mo> <mi 
>y</mi></math><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> [*]</span></p></dd></dl>
             </dd></dl>
         </dd></dl>
     <!--l. 126--><p class="noindent" ><span 
class="ectt-1000">return</span><span 
class="ectt-1000"> </span><!--l. 126--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math></p></dd></dl>
<figcaption class="caption" ><span class="id">Algorithm 1:</span><span  
class="content">Metropolis-Hastings Markov Chain Monte Carlo method</span></figcaption><!--tex4ht:label?: x1-2001r1 -->
   </figure>
<!--l. 131--><p class="indent" >   One obvious way to speed up the M-H MCMC method is to take advantage of the gradient of
<!--l. 132--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></math> with respect to
<!--l. 132--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math> and use it to ﬁnd
<!--l. 133--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math> with higher probability. That
gradient still depends on <!--l. 134--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>Z</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></math>
however as </p><table class="equation-star"><tr><td>
<!--l. 135--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                          <msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>x</mi></mrow></msub 
><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-rel">=</mo>  <mfrac><mrow 
><mn>1</mn></mrow> 
<mrow 
><msub><mrow 
><mi 
>Z</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></mrow></mfrac><mi class="qopname"> exp</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>x</mi></mrow></msub 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-punc">.</mo>
</math></td></tr></table>
<!--l. 138--><p class="indent" >   Fortunately the gradient of <!--l. 138--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi class="qopname"> log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math>,
also called the <span 
class="ecti-1000">score function </span><!--l. 139--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>s</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math>
only depends on <!--l. 139--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math>
because </p><table class="equation-star"><tr><td>
<!--l. 141--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                  <msub><mrow 
><mi 
>s</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-rel">=</mo> <msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>x</mi></mrow></msub 
><mi class="qopname"> log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-rel">=</mo> <msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>x</mi></mrow></msub 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">−</mo><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>x</mi></mrow></msub 
><mi class="qopname"> log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><msub><mrow 
><mi 
>Z</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
> <mo 
class="MathClass-rel">=</mo> <msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>x</mi></mrow></msub 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-punc">.</mo>
</math></td></tr></table>
<!--l. 144--><p class="indent" >   The last step of the derivation works because <!--l. 144--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>Z</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></math>
does not depend on <!--l. 145--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math> and hence
<!--l. 145--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>x</mi></mrow></msub 
><mi class="qopname"> log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><msub><mrow 
><mi 
>Z</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
> <mo 
class="MathClass-rel">=</mo> <mn>0</mn></math>. The Langevin MCMC method, described in
Algorithm <a 
href="#x1-2002r2">2<!--tex4ht:ref: alg:Langevin-MCMC --></a>, works exactly by levaraging <!--l. 147--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>s</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math>.
Again, the randomization in the * step helps the algorithm get out of local maximum and sample more space of
<!--l. 149--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math>.
</p><!--l. 151--><p class="indent" >   <a 
 id="x1-2002r2"></a></p><figure class="float" 
>
     <dl class="list1"><dt class="list">
     </dt><dd 
class="list">
     <!--l. 151--><p class="noindent" ><!--l. 152--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi> <mo 
class="MathClass-punc">:</mo><mo 
class="MathClass-rel">=</mo></math><span 
class="ectt-1000">norm_random()</span>
     </p><!--l. 154--><p class="noindent" ><span 
class="ectt-1000">until</span><span 
class="ectt-1000"> convergence:</span>
         </p><dl class="list2"><dt class="list">
         </dt><dd 
class="list">
         <!--l. 155--><p class="noindent" ><!--l. 156--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi> <mo 
class="MathClass-punc">:</mo><mo 
class="MathClass-rel">=</mo> <mi 
>x</mi> <mo 
class="MathClass-bin">+</mo> <mi 
>𝜖</mi> <mo 
class="MathClass-bin">⋅</mo> <msub><mrow 
><mi 
>s</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">+</mo> <msqrt><mrow><mn>2</mn><mi 
>𝜖</mi></mrow></msqrt><mo 
class="MathClass-bin">⋅</mo></math><span 
class="ectt-1000">norm_random()</span><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> [*]</span></p></dd></dl>
     <!--l. 158--><p class="noindent" ><span 
class="ectt-1000">return</span><span 
class="ectt-1000"> </span><!--l. 158--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math>
</p>
     <figcaption class="caption" ><span class="id"><span 
class="ectt-1000">Algorithm 2:</span></span><span  
class="content"><span 
class="ectt-1000">Langevin MCMC method</span></span></figcaption><!--tex4ht:label?: x1-2002r2 -->
     </dd></dl>
   </figure>
   <h3 class="sectionHead"><span class="titlemark">3   </span> <a 
 id="x1-30003"></a>Training</h3>
<!--l. 165--><p class="noindent" >There are multiple diﬀerent ways of training EBMs. Some require sampling from the model being trained, and others do not.
</p><!--l. 168--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">3.1   </span> <a 
 id="x1-40003.1"></a>Maximum Likelihood Method or Contrastive Divergence</h4>
<!--l. 170--><p class="noindent" >Surprisingly, it is possible to conduct maximum likelihood optimization for EBM without modeling the PDF. Let’s start with a little
math:
</p><!--tex4ht:inline--><!--l. 175--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" ><mtable 
columnalign="left" class="align-star">
                                    <mtr><mtd 
columnalign="right" class="align-odd"><mi class="qopname"> max</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>x</mi><mo 
class="MathClass-rel">∼</mo><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></msub 
><mi class="qopname"> log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mtd>                                    <mtd 
class="align-even"> <mo 
class="MathClass-rel">=</mo><munder class="msub"><mrow 
><mi class="qopname"> max</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></munder 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>x</mi><mo 
class="MathClass-rel">∼</mo><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></msub 
><mo 
class="MathClass-open">[</mo><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">−</mo><mi class="qopname"> log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><msub><mrow 
><mi 
>Z</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-close">]</mo><mspace width="2em"/></mtd>                                    <mtd 
columnalign="right" class="align-label"></mtd>                                    <mtd 
class="align-label">
                                    <mspace width="2em"/></mtd></mtr><mtr><mtd 
columnalign="right" class="align-odd"></mtd>                                                      <mtd 
class="align-even"> <mo 
class="MathClass-rel">=</mo><munder class="msub"><mrow 
><mi class="qopname"> max</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></munder 
><mo 
class="MathClass-open">[</mo><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>x</mi><mo 
class="MathClass-rel">∼</mo><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></msub 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">−</mo><mi class="qopname"> log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><msub><mrow 
><mi 
>Z</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-close">]</mo><mspace width="2em"/></mtd>                                    <mtd 
columnalign="right" class="align-label"></mtd>                                    <mtd 
class="align-label">
   <mspace width="2em"/></mtd></mtr></mtable></math>
<!--l. 176--><p class="noindent" >The likelihood gradient for updating <!--l. 176--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>𝜃</mi></math>
is
</p><!--tex4ht:inline--><!--l. 187--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" ><mtable 
columnalign="left" class="align-star">
                         <mtr><mtd 
columnalign="right" class="align-odd"><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">[</mo><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>x</mi><mo 
class="MathClass-rel">∼</mo><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></msub 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">−</mo><mi class="qopname"> log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><msub><mrow 
><mi 
>Z</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-close">]</mo></mtd>                         <mtd 
class="align-even"> <mo 
class="MathClass-rel">=</mo> <msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>x</mi><mo 
class="MathClass-rel">∼</mo><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></msub 
><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">−</mo><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mi class="qopname"> log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><msub><mrow 
><mi 
>Z</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mspace width="2em"/></mtd>                                          <mtd 
columnalign="right" class="align-label"></mtd>                         <mtd 
class="align-label">
                         <mspace width="2em"/></mtd></mtr><mtr><mtd 
columnalign="right" class="align-odd"></mtd>                                                <mtd 
class="align-even"> <mo 
class="MathClass-rel">=</mo> <msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>x</mi><mo 
class="MathClass-rel">∼</mo><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></msub 
><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">−</mo><mstyle 
class="text"><mtext  ></mtext><mstyle 
class="math"> <mfrac><mrow 
><mn>1</mn></mrow>
<mrow 
><msub><mrow 
><mi 
>Z</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></mrow></mfrac><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><msub><mrow 
><mi 
>Z</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></mstyle><mtext  ></mtext></mstyle><mspace width="2em"/></mtd>                                          <mtd 
columnalign="right" class="align-label"></mtd>                         <mtd 
class="align-label">
                         <mspace width="2em"/></mtd></mtr><mtr><mtd 
columnalign="right" class="align-odd"></mtd>                                                <mtd 
class="align-even"> <mo 
class="MathClass-rel">=</mo> <msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>x</mi><mo 
class="MathClass-rel">∼</mo><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></msub 
><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">−</mo> <mfrac><mrow 
><mn>1</mn></mrow> 
<mrow 
><msub><mrow 
><mi 
>Z</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></mrow></mfrac><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">[</mo><mo  
>∫
 <!--nolimits--></mo><!--nolimits--><mi class="qopname">exp</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo><mi 
>d</mi><mi 
>x</mi><mo 
class="MathClass-close">]</mo><mspace width="2em"/></mtd>                             <mtd 
columnalign="right" class="align-label"></mtd>                         <mtd 
class="align-label">
                         <mspace width="2em"/></mtd></mtr><mtr><mtd 
columnalign="right" class="align-odd"></mtd>                                                <mtd 
class="align-even"> <mo 
class="MathClass-rel">=</mo> <msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>x</mi><mo 
class="MathClass-rel">∼</mo><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></msub 
><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">−</mo> <mfrac><mrow 
><mn>1</mn></mrow> 
<mrow 
><msub><mrow 
><mi 
>Z</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></mrow></mfrac><mo  
> ∫
 <!--nolimits--></mo><!--nolimits--><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mi class="qopname"> exp</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo><mi 
>d</mi><mi 
>x</mi><mspace width="2em"/></mtd>                              <mtd 
columnalign="right" class="align-label"></mtd>                         <mtd 
class="align-label">
                         <mspace width="2em"/></mtd></mtr><mtr><mtd 
columnalign="right" class="align-odd"></mtd>                                                <mtd 
class="align-even"> <mo 
class="MathClass-rel">=</mo> <msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>x</mi><mo 
class="MathClass-rel">∼</mo><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></msub 
><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">−</mo> <mfrac><mrow 
><mn>1</mn></mrow> 
<mrow 
><msub><mrow 
><mi 
>Z</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></mrow></mfrac><mo  
> ∫
 <!--nolimits--></mo><!--nolimits--><mi class="qopname">exp</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mi 
>d</mi><mi 
>x</mi><mspace width="2em"/></mtd>                         <mtd 
columnalign="right" class="align-label"></mtd>                         <mtd 
class="align-label">
                         <mspace width="2em"/></mtd></mtr><mtr><mtd 
columnalign="right" class="align-odd"></mtd>                                                <mtd 
class="align-even"> <mo 
class="MathClass-rel">=</mo> <msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>x</mi><mo 
class="MathClass-rel">∼</mo><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></msub 
><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">−</mo> <mfrac><mrow 
><mn>1</mn></mrow> 
<mrow 
><msub><mrow 
><mi 
>Z</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></mrow></mfrac><mo  
> ∫
 <!--nolimits--></mo><!--nolimits--><mi class="qopname">exp</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mi 
>d</mi><mi 
>x</mi><mspace width="2em"/></mtd>                         <mtd 
columnalign="right" class="align-label"></mtd>                         <mtd 
class="align-label">
                         <mspace width="2em"/></mtd></mtr><mtr><mtd 
columnalign="right" class="align-odd"></mtd>                                                <mtd 
class="align-even"> <mo 
class="MathClass-rel">=</mo> <msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>x</mi><mo 
class="MathClass-rel">∼</mo><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></msub 
><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">−</mo><mo  
>∫
 <!--nolimits--></mo><!--nolimits--> <mfrac><mrow 
><mn>1</mn></mrow> 
<mrow 
><msub><mrow 
><mi 
>Z</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></mrow></mfrac><mi class="qopname"> exp</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mi 
>d</mi><mi 
>x</mi><mspace width="2em"/></mtd>                         <mtd 
columnalign="right" class="align-label"></mtd>                         <mtd 
class="align-label">
                         <mspace width="2em"/></mtd></mtr><mtr><mtd 
columnalign="right" class="align-odd"></mtd>                                                <mtd 
class="align-even"> <mo 
class="MathClass-rel">=</mo> <msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>x</mi><mo 
class="MathClass-rel">∼</mo><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></msub 
><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">−</mo><mo  
>∫
 <!--nolimits--></mo><!--nolimits--><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mi 
>d</mi><mi 
>x</mi><mspace width="2em"/></mtd>                                 <mtd 
columnalign="right" class="align-label"></mtd>                         <mtd 
class="align-label">
                         <mspace width="2em"/></mtd></mtr><mtr><mtd 
columnalign="right" class="align-odd"></mtd>                                                <mtd 
class="align-even"> <mo 
class="MathClass-rel">=</mo> <msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>x</mi><mo 
class="MathClass-rel">∼</mo><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></msub 
><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">−</mo> <msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>x</mi><mo 
class="MathClass-rel">∼</mo><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></msub 
><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mspace width="2em"/></mtd>                                   <mtd 
columnalign="right" class="align-label"></mtd>                         <mtd 
class="align-label">
   <mspace width="2em"/></mtd></mtr></mtable></math>
<!--l. 188--><p class="noindent" >Note that the ﬁrst term involves <!--l. 188--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math>, the second
term involves <!--l. 189--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math>, and neither depends on
<!--l. 189--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>Z</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></math>. Also note that here the likelihood gradient
is with respect to <!--l. 190--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>𝜃</mi></math>, the parameters, not
<!--l. 191--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math>. Don’t confuse it with the score function,
which is a gradient with respect to <!--l. 192--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math>.
The likelihood gradient points in the direction where the energy function’s gradient diﬀers the most between real samples and model samples. This is
probably where the name Contrastive Divergence got its name.
</p><!--l. 197--><p class="indent" >   The big picture here is that even though the partition function <!--l. 197--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>Z</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></math>
is not modeled, it is still possible to estimate the likelihood function’s gradient and conduct maximum likelihood training. Each
training step though requires drawing samples from the model being trained, which can be expensive, as described in Section
<a 
href="#x1-20002">2<!--tex4ht:ref: sec:Sampling --></a>.
</p><!--l. 203--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">3.2   </span> <a 
 id="x1-50003.2"></a>Score Matching</h4>
<!--l. 205--><p class="noindent" >If <!--l. 205--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>x</mi></mrow></msub 
><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math> and
<!--l. 205--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>x</mi></mrow></msub 
><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math> are equal everywhere,
then <!--l. 206--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-rel">=</mo> <msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-bin">+</mo></math>constant.
Therefore, if <!--l. 206--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>x</mi></mrow></msub 
><mi class="qopname"> log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math> and
<!--l. 207--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>x</mi></mrow></msub 
><mi class="qopname"> log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math> are equal everywhere, then
<!--l. 207--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi class="qopname"> log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-rel">=</mo><mi class="qopname"> log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-bin">+</mo></math>constant. That constant diﬀerence
can be removed since both <!--l. 208--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math>
and <!--l. 208--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math> have
to integrate to 1.
</p><!--l. 211--><p class="indent" >   That is the key idea behind score matching, a method that matches the scores or score functions of two distributions everywhere as an
alternative to maximum likelihood based training. The objective of score matching is to minimize the Fisher Divergence between
<!--l. 214--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math> and
<!--l. 215--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math>:
</p><!--tex4ht:inline--><!--l. 219--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" ><mtable 
columnalign="left" class="align-star">
                              <mtr><mtd 
columnalign="right" class="align-odd"><munder class="msub"><mrow 
><mi class="qopname"> min</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></munder 
><mi 
>F</mi><mi 
>D</mi><mo 
class="MathClass-open">(</mo><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-punc">,</mo><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo></mtd>                              <mtd 
class="align-even"> <mo 
class="MathClass-rel">=</mo><munder class="msub"><mrow 
><mi class="qopname"> min</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></munder 
><mfrac><mrow 
><mn>1</mn></mrow> 
<mrow 
><mn>2</mn></mrow></mfrac><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>x</mi><mo 
class="MathClass-rel">∼</mo><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></msub 
><msubsup><mrow 
> <mrow><mo fence="true" form="prefix"> ∥</mo><mrow><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>x</mi></mrow></msub 
><mi class="qopname"> log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">−</mo><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>x</mi></mrow></msub 
><mi class="qopname"> log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow><mo fence="true" form="postfix">∥</mo></mrow></mrow><mrow 
><mn>2</mn></mrow><mrow 
><mn>2</mn></mrow></msubsup 
><mspace width="2em"/></mtd>                              <mtd 
columnalign="right" class="align-label"></mtd>                              <mtd 
class="align-label">
                              <mspace width="2em"/></mtd></mtr><mtr><mtd 
columnalign="right" class="align-odd"></mtd>                                                <mtd 
class="align-even"> <mo 
class="MathClass-rel">=</mo><munder class="msub"><mrow 
><mi class="qopname"> min</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></munder 
><mfrac><mrow 
><mn>1</mn></mrow> 
<mrow 
><mn>2</mn></mrow></mfrac><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>x</mi><mo 
class="MathClass-rel">∼</mo><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></msub 
><msubsup><mrow 
> <mrow><mo fence="true" form="prefix"> ∥</mo><mrow><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>x</mi></mrow></msub 
><mi class="qopname"> log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">−</mo><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>x</mi></mrow></msub 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow><mo fence="true" form="postfix">∥</mo></mrow></mrow><mrow 
><mn>2</mn></mrow><mrow 
><mn>2</mn></mrow></msubsup 
><mspace width="2em"/></mtd>                                <mtd 
columnalign="right" class="align-label"></mtd>                              <mtd 
class="align-label">
   <mspace width="2em"/></mtd></mtr></mtable></math>
<!--l. 221--><p class="noindent" >We’ll show how this objective can be manipulated to not dependent on the unknown
<!--l. 222--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math> in the
univariate case.

</p><!--tex4ht:inline--><!--l. 227--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" ><mtable 
columnalign="left" class="align">
           <mtr><mtd 
columnalign="right" class="align-odd"><munder class="msub"><mrow 
><mi class="qopname"> min</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></munder 
><mfrac><mrow 
><mn>1</mn></mrow> 
<mrow 
><mn>2</mn></mrow></mfrac><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>x</mi><mo 
class="MathClass-rel">∼</mo><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></msub 
><msubsup><mrow 
> <mrow><mo fence="true" form="prefix"> ∥</mo><mrow><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>x</mi></mrow></msub 
><mi class="qopname"> log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">−</mo><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>x</mi></mrow></msub 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow><mo fence="true" form="postfix">∥</mo></mrow></mrow><mrow 
><mn>2</mn></mrow><mrow 
><mn>2</mn></mrow></msubsup 
></mtd>           <mtd 
class="align-even"> <mo 
class="MathClass-rel">=</mo><munder class="msub"><mrow 
><mi class="qopname"> min</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo></mrow><mrow 
>
<mi 
>𝜃</mi></mrow></munder 
><mfrac><mrow 
><mn>1</mn></mrow> 
<mrow 
><mn>2</mn></mrow></mfrac><mo  
>∫
 <!--nolimits--></mo><!--nolimits--><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><msup><mrow 
><mo 
class="MathClass-open">[</mo><msup><mrow 
><mi class="qopname">log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow 
><mi 
>′</mi></mrow></msup 
><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">−</mo> <msubsup><mrow 
><mi 
>E</mi></mrow><mrow 
>
<mi 
>𝜃</mi></mrow><mrow 
><msup><mrow 
></mrow><mrow 
><mi 
>′</mi></mrow></msup 
>
 </mrow></msubsup 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">]</mo></mrow><mrow 
><mn>2</mn></mrow></msup 
><mspace width="2em"/></mtd>                                           <mtd 
columnalign="right" class="align-label"></mtd>           <mtd 
class="align-label">
           <mspace width="2em"/></mtd></mtr><mtr><mtd 
columnalign="right" class="align-odd"></mtd>                                             <mtd 
class="align-even"> <mo 
class="MathClass-rel">=</mo><munder class="msub"><mrow 
><mi class="qopname"> min</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></munder 
><mfrac><mrow 
><mn>1</mn></mrow> 
<mrow 
><mn>2</mn></mrow></mfrac><mo  
>∫
 <!--nolimits--></mo><!--nolimits--><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-open">[</mo><msup><mrow 
><mo 
class="MathClass-open">(</mo><msup><mrow 
><mi class="qopname">log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow 
><mi 
>′</mi></mrow></msup 
><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo></mrow><mrow 
><mn>2</mn></mrow></msup 
> <mo 
class="MathClass-bin">+</mo> <msup><mrow 
><mo 
class="MathClass-open">(</mo><msubsup><mrow 
><mi 
>E</mi></mrow><mrow 
>
<mi 
>𝜃</mi></mrow><mrow 
><msup><mrow 
></mrow><mrow 
><mi 
>′</mi></mrow></msup 
>
 </mrow></msubsup 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo></mrow><mrow 
><mn>2</mn></mrow></msup 
> <mo 
class="MathClass-bin">−</mo> <mn>2</mn><msup><mrow 
><mi class="qopname">log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow 
><mi 
>′</mi></mrow></msup 
><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><msubsup><mrow 
><mi 
>E</mi></mrow><mrow 
>
<mi 
>𝜃</mi></mrow><mrow 
><msup><mrow 
></mrow><mrow 
><mi 
>′</mi></mrow></msup 
>
 </mrow></msubsup 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">]</mo><mspace width="2em"/></mtd>                       <mtd 
columnalign="right" class="align-label"></mtd>           <mtd 
class="align-label">
           <mspace width="2em"/></mtd></mtr><mtr><mtd 
columnalign="right" class="align-odd"></mtd>                                             <mtd 
class="align-even"> <mo 
class="MathClass-rel">=</mo><munder class="msub"><mrow 
><mi class="qopname"> min</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></munder 
><mo 
class="MathClass-open">[</mo><mfrac><mrow 
><mn>1</mn></mrow>
<mrow 
><mn>2</mn></mrow></mfrac><mo  
>∫
 <!--nolimits--></mo><!--nolimits--><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><msup><mrow 
><mo 
class="MathClass-open">(</mo><msup><mrow 
><mi class="qopname">log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow 
><mi 
>′</mi></mrow></msup 
><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo></mrow><mrow 
><mn>2</mn></mrow></msup 
> <mo 
class="MathClass-bin">+</mo> <mfrac><mrow 
><mn>1</mn></mrow> 
<mrow 
><mn>2</mn></mrow></mfrac><mo  
>∫
 <!--nolimits--></mo><!--nolimits--><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><msup><mrow 
><mo 
class="MathClass-open">(</mo><msubsup><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow><mrow 
><msup><mrow 
></mrow><mrow 
><mi 
>′</mi></mrow></msup 
>
 </mrow></msubsup 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo></mrow><mrow 
><mn>2</mn></mrow></msup 
> <mo 
class="MathClass-bin">−</mo><mo  
>∫
 <!--nolimits--></mo><!--nolimits--><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><msup><mrow 
><mi class="qopname">log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow 
><mi 
>′</mi></mrow></msup 
><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><msubsup><mrow 
><mi 
>E</mi></mrow><mrow 
>
<mi 
>𝜃</mi></mrow><mrow 
><msup><mrow 
></mrow><mrow 
><mi 
>′</mi></mrow></msup 
>
 </mrow></msubsup 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">]</mo><mspace width="2em"/></mtd>                      <mtd 
columnalign="right" class="align-label"><mstyle 
   id="x1-5001r2"  class="label" ></mstyle><!--endlabel--><mstyle 
class="maketag"><mtext  >(2)</mtext></mstyle><mspace width="0.33em" class="nbsp" />
   </mtd></mtr></mtable></math>
<!--l. 228--><p class="noindent" >The ﬁrst term does not depend on <!--l. 228--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>𝜃</mi></math>, and can
therefore be left out. The third term still has <!--l. 229--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msup><mrow 
><mi class="qopname"> log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow 
><mi 
>′</mi></mrow></msup 
><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math>
in it. Recall the integration by parts formula states that </p><table class="equation-star"><tr><td>
<!--l. 231--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                     <msubsup><mrow 
><mo  
>∫
 <!--nolimits--></mo><!--nolimits--></mrow><mrow 
><mi 
>a</mi></mrow><mrow 
><mi 
>b</mi></mrow></msubsup 
><mi 
>u</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><msup><mrow 
><mi 
>v</mi></mrow><mrow 
><mi 
>′</mi></mrow></msup 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mi 
>d</mi><mi 
>x</mi> <mo 
class="MathClass-rel">=</mo> <mi 
>u</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mi 
>v</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><msubsup><mrow 
><mo 
class="MathClass-rel">|</mo></mrow><mrow 
>
<mi 
>a</mi></mrow><mrow 
><mi 
>b</mi></mrow></msubsup 
> <mo 
class="MathClass-bin">−</mo><msubsup><mrow 
><mo  
>∫ 
<!--nolimits--></mo><!--nolimits--></mrow><mrow 
><mi 
>a</mi></mrow><mrow 
><mi 
>b</mi></mrow></msubsup 
><msup><mrow 
><mi 
>u</mi></mrow><mrow 
><mi 
>′</mi></mrow></msup 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mi 
>v</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mi 
>d</mi><mi 
>x</mi>
</math></td></tr></table>
<!--l. 234--><p class="indent" >   and it can be used the rewrite the third term:
</p><!--tex4ht:inline--><!--l. 241--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" ><mtable 
columnalign="left" class="align">
                                   <mtr><mtd 
columnalign="right" class="align-odd"><mo  
> ∫
 <!--nolimits--></mo><!--nolimits--><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><msup><mrow 
><mi class="qopname">log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow 
><mi 
>′</mi></mrow></msup 
><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><msubsup><mrow 
><mi 
>E</mi></mrow><mrow 
>
<mi 
>𝜃</mi></mrow><mrow 
><msup><mrow 
></mrow><mrow 
><mi 
>′</mi></mrow></msup 
>
 </mrow></msubsup 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mtd>                                   <mtd 
class="align-even"> <mo 
class="MathClass-rel">=</mo><mo  
> ∫
 <!--nolimits--></mo><!--nolimits--><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo>  <mfrac><mrow 
><mn>1</mn></mrow>
<mrow 
><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></mfrac><msup><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>′</mi></mrow></msup 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><msubsup><mrow 
><mi 
>E</mi></mrow><mrow 
>
<mi 
>𝜃</mi></mrow><mrow 
><msup><mrow 
></mrow><mrow 
><mi 
>′</mi></mrow></msup 
>
 </mrow></msubsup 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mspace width="2em"/></mtd>                                            <mtd 
columnalign="right" class="align-label"></mtd>                                   <mtd 
class="align-label">
                                   <mspace width="2em"/></mtd></mtr><mtr><mtd 
columnalign="right" class="align-odd"></mtd>                                                      <mtd 
class="align-even"> <mo 
class="MathClass-rel">=</mo><mo  
> ∫
 <!--nolimits--></mo><!--nolimits--><msup><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>′</mi></mrow></msup 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><msubsup><mrow 
><mi 
>E</mi></mrow><mrow 
>
<mi 
>𝜃</mi></mrow><mrow 
><msup><mrow 
></mrow><mrow 
><mi 
>′</mi></mrow></msup 
>
 </mrow></msubsup 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mspace width="2em"/></mtd>                                                   <mtd 
columnalign="right" class="align-label"></mtd>                                   <mtd 
class="align-label">
                                   <mspace width="2em"/></mtd></mtr><mtr><mtd 
columnalign="right" class="align-odd"></mtd>                                                      <mtd 
class="align-even"> <mo 
class="MathClass-rel">=</mo> <mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><msubsup><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow><mrow 
><msup><mrow 
></mrow><mrow 
><mi 
>′</mi></mrow></msup 
>
 </mrow></msubsup 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><msubsup><mrow 
><mo 
class="MathClass-rel">|</mo></mrow><mrow 
><mo 
class="MathClass-bin">−</mo><mi 
>∞</mi></mrow><mrow 
><mo 
class="MathClass-bin">+</mo><mi 
>∞</mi></mrow></msubsup 
><mo 
class="MathClass-bin">−</mo><mo  
>∫
 <!--nolimits--></mo><!--nolimits--><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><msubsup><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow><mrow 
><msup><mrow 
></mrow><mrow 
><mo>″</mo></mrow></msup 
></mrow></msubsup 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mspace width="2em"/></mtd>                                   <mtd 
columnalign="right" class="align-label"></mtd>                                   <mtd 
class="align-label">
                                   <mspace width="2em"/></mtd></mtr><mtr><mtd 
columnalign="right" class="align-odd"></mtd>                                                      <mtd 
class="align-even"> <mo 
class="MathClass-rel">=</mo> <mn>0</mn> <mo 
class="MathClass-bin">−</mo><mo  
>∫
 <!--nolimits--></mo><!--nolimits--><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><msubsup><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow><mrow 
><msup><mrow 
></mrow><mrow 
><mo>″</mo></mrow></msup 
></mrow></msubsup 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mspace width="2em"/></mtd>                                                                                    <mtd 
columnalign="right" class="align-label"><mstyle 
   id="x1-5002r3"  class="label" ></mstyle><!--endlabel--><mstyle 
class="maketag"><mtext  >(3)</mtext></mstyle><mspace width="0.33em" class="nbsp" />
                                   </mtd></mtr><mtr><mtd 
columnalign="right" class="align-odd"></mtd>                                                      <mtd 
class="align-even"> <mo 
class="MathClass-rel">=</mo> <mo 
class="MathClass-bin">−</mo><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>x</mi><mo 
class="MathClass-rel">∼</mo><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></msub 
><msubsup><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow><mrow 
><msup><mrow 
></mrow><mrow 
><mi 
class="MathClass-op">″</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow></msup 
></mrow></msubsup 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mspace width="2em"/></mtd>                                                                                     <mtd 
columnalign="right" class="align-label"><mstyle 
   id="x1-5003r4"  class="label" ></mstyle><!--endlabel--><mstyle 
class="maketag"><mtext  >(4)</mtext></mstyle><mspace width="0.33em" class="nbsp" />
   </mtd></mtr></mtable></math>
<!--l. 242--><p class="noindent" >The derivation of (<a 
href="#x1-5002r3">3<!--tex4ht:ref: eq:third-term-1 --></a>) makes the very reasonable assumption that <!--l. 243--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><munder class="msub"><mrow 
><mi class="qopname"> lim</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo></mrow><mrow 
><mo 
class="MathClass-bin">+</mo><mi 
>∞</mi></mrow></munder 
><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-rel">=</mo><munder class="msub"><mrow 
><mi class="qopname"> lim</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo></mrow><mrow 
><mo 
class="MathClass-bin">−</mo><mi 
>∞</mi></mrow></munder 
><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-rel">=</mo> <mn>0</mn></math>.
</p><!--l. 245--><p class="indent" >   Eliminating the ﬁrst term in (<a 
href="#x1-5001r2">2<!--tex4ht:ref: eq:three-terms --></a>), rewriting the second term in the expectation form, and subtituting the third term with (<a 
href="#x1-5003r4">4<!--tex4ht:ref: eq:third-term-2 --></a>), we have
</p><table class="equation-star"><tr><td>

<!--l. 248--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                        <munder class="msub"><mrow 
><mi class="qopname">min</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></munder 
><mo 
class="MathClass-open">[</mo><mfrac><mrow 
><mn>1</mn></mrow>
<mrow 
><mn>2</mn></mrow></mfrac><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>x</mi><mo 
class="MathClass-rel">∼</mo><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></msub 
><msup><mrow 
><mo 
class="MathClass-open">(</mo><msubsup><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow><mrow 
><msup><mrow 
></mrow><mrow 
><mi 
>′</mi></mrow></msup 
>
 </mrow></msubsup 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo></mrow><mrow 
><mn>2</mn></mrow></msup 
> <mo 
class="MathClass-bin">+</mo> <msub><mrow 
><mi 
>E</mi></mrow><mrow 
>
<mi 
>x</mi><mo 
class="MathClass-rel">∼</mo><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></msub 
><msubsup><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow><mrow 
><msup><mrow 
></mrow><mrow 
><mi class="qopname">″</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo></mrow></msup 
></mrow></msubsup 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">]</mo> <mo 
class="MathClass-rel">=</mo><munder class="msub"><mrow 
><mi class="qopname"> min</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo></mrow><mrow 
>
<mi 
>𝜃</mi></mrow></munder 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>x</mi><mo 
class="MathClass-rel">∼</mo><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></msub 
><mo 
class="MathClass-open">[</mo><mfrac><mrow 
><mn>1</mn></mrow>
<mrow 
><mn>2</mn></mrow></mfrac><msup><mrow 
><mo 
class="MathClass-open">(</mo><msubsup><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow><mrow 
><msup><mrow 
></mrow><mrow 
><mi 
>′</mi></mrow></msup 
>
 </mrow></msubsup 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo></mrow><mrow 
><mn>2</mn></mrow></msup 
> <mo 
class="MathClass-bin">+</mo> <msubsup><mrow 
><mi 
>E</mi></mrow><mrow 
>
<mi 
>𝜃</mi></mrow><mrow 
><msup><mrow 
></mrow><mrow 
><mi class="qopname">″</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo></mrow></msup 
></mrow></msubsup 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">]</mo><mo 
class="MathClass-punc">.</mo>
</math></td></tr></table>
<!--l. 251--><p class="indent" >   The multivariate version of the objective can be shown to be </p><table class="equation-star"><tr><td>
<!--l. 252--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                       <munder class="msub"><mrow 
><mi class="qopname">min</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></munder 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>x</mi><mo 
class="MathClass-rel">∼</mo><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></msub 
><mo 
class="MathClass-open">[</mo><mfrac><mrow 
><mn>1</mn></mrow>
<mrow 
><mn>2</mn></mrow></mfrac><msubsup><mrow 
> <mrow><mo fence="true" form="prefix"> ∥</mo><mrow><msub><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow><mo fence="true" form="postfix">∥</mo></mrow></mrow><mrow 
><mn>2</mn></mrow><mrow 
><mn>2</mn></mrow></msubsup 
> <mo 
class="MathClass-bin">+</mo> <mi 
>t</mi><mi 
>r</mi><mo 
class="MathClass-open">(</mo><msubsup><mrow 
><mi 
class="MathClass-op">∇</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--></mo></mrow><mrow 
>
<mi 
>𝜃</mi></mrow><mrow 
><mn>2</mn></mrow></msubsup 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
>
<mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">]</mo>
</math></td></tr></table>
<!--l. 255--><p class="indent" >   where the second term is the trace of the Hessian matrix of <!--l. 255--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math>.
Loosely speaking, the ﬁrst term tries to ﬁnd <!--l. 256--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>𝜃</mi></math>
such that the samples <!--l. 257--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math>
are the local maximums or minimums (with gradients as close to 0 as possible), and the second term tries to make sure it is actually local maximums
(with second order gradients as negative as possible).
</p><!--l. 262--><p class="indent" >   The score matching training method avoids the very expensive procedure of drawing samples from the model being trained. Its main expensive
operation is the computation of the trace of the Hessian matrix. There are more research in this space that will be explored in future
tutorials.
</p><!--l. 267--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">3.3   </span> <a 
 id="x1-60003.3"></a>Noise Contrastive Estimation</h4>
<!--l. 269--><p class="noindent" >Noise Contrastive Estimation (NCE) is another training method for EBMs without requiring drawing samples from the models
being trained. Recall that in Generative Adversarial Networks (GAN) (<a 
href="amaires.github.io/GAN" class="url" ><span 
class="ectt-1000">amaires.github.io/GAN</span></a>), given a ﬁxed Generator
<!--l. 272--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>G</mi></mrow><mrow 
><mi 
>ϕ</mi></mrow></msub 
></math>, the optimal
Discriminator <!--l. 272--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>D</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></math>’s
output is </p><table class="equation-star"><tr><td>
<!--l. 274--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                                <msub><mrow 
><mi 
>D</mi></mrow><mrow 
><msup><mrow 
><mi 
>𝜃</mi></mrow><mrow 
><mo 
class="MathClass-bin">∗</mo></mrow></msup 
></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-rel">=</mo>       <mfrac><mrow 
><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow> 
<mrow 
><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">+</mo> <msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>ϕ</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></mfrac>
</math></td></tr></table>
<!--l. 277--><p class="indent" >   The result holds if <!--l. 277--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>G</mi></mrow><mrow 
><mi 
>ϕ</mi></mrow></msub 
></math> and
<!--l. 277--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>ϕ</mi></mrow></msub 
></math> are replaced with any static
known noise distribution <!--l. 278--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>n</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math>.
That is </p><table class="equation-star"><tr><td>

<!--l. 279--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                                <msub><mrow 
><mi 
>D</mi></mrow><mrow 
><msup><mrow 
><mi 
>𝜃</mi></mrow><mrow 
><mo 
class="MathClass-bin">∗</mo></mrow></msup 
></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-rel">=</mo>       <mfrac><mrow 
><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow> 
<mrow 
><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">+</mo> <msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>n</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></mfrac>
</math></td></tr></table>
<!--l. 282--><p class="indent" >   Note here <!--l. 282--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>n</mi></math> is
not a parameter; it just means noise.
</p><!--l. 284--><p class="indent" >   If <!--l. 284--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>D</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></math>’s
neural network is explicitly constructed as </p><table class="equation-star"><tr><td>
<!--l. 285--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                               <msub><mrow 
><mi 
>D</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-rel">=</mo>       <mfrac><mrow 
><msub><mrow 
><mi 
>F</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow> 
<mrow 
><msub><mrow 
><mi 
>F</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">+</mo> <msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>n</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></mfrac>
</math></td></tr></table>
<!--l. 288--><p class="indent" >   then </p><table class="equation-star"><tr><td>
<!--l. 289--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                        <msub><mrow 
><mi 
>D</mi></mrow><mrow 
><msup><mrow 
><mi 
>𝜃</mi></mrow><mrow 
><mo 
class="MathClass-bin">∗</mo></mrow></msup 
></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-rel">=</mo>       <mfrac><mrow 
><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow> 
<mrow 
><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">+</mo> <msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>n</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></mfrac> <mo 
class="MathClass-rel">≃</mo>   <mfrac><mrow 
><msub><mrow 
><mi 
>F</mi></mrow><mrow 
><msup><mrow 
><mi 
>𝜃</mi></mrow><mrow 
><mo 
class="MathClass-bin">∗</mo></mrow></msup 
></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow> 
<mrow 
><msub><mrow 
><mi 
>F</mi></mrow><mrow 
><msup><mrow 
><mi 
>𝜃</mi></mrow><mrow 
><mo 
class="MathClass-bin">∗</mo></mrow></msup 
></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">+</mo> <msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>n</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></mfrac>
</math></td></tr></table>
<!--l. 292--><p class="indent" >   solving it basically shows that <!--l. 292--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>F</mi></mrow><mrow 
><msup><mrow 
><mi 
>𝜃</mi></mrow><mrow 
><mo 
class="MathClass-bin">∗</mo></mrow></msup 
></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-rel">≃</mo> <mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math>
which also means <!--l. 293--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>F</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math> is automatically
normalized if all stars are aligned. Now if <!--l. 294--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>F</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math>
is replaced with an energy function based PDF function </p><table class="equation-star"><tr><td>
<!--l. 296--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                                     <mfrac><mrow 
><mi class="qopname"> exp</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo></mrow>
      <mrow 
><mi 
>Z</mi></mrow></mfrac>
</math></td></tr></table>
<!--l. 299--><p class="indent" >   where <!--l. 299--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>Z</mi></math> is an additional parameter,
which is not guaranteed to be equal to <!--l. 300--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math>’s
partition function <!--l. 300--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>Z</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></math>,
we have </p><table class="equation"><tr><td> <a 
 id="x1-6001r5"></a>

<!--l. 302--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                   <msub><mrow 
><mi 
>D</mi></mrow><mrow 
><mi 
>𝜃</mi><mo 
class="MathClass-punc">,</mo><mi 
>Z</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-rel">=</mo>       <mfrac><mrow 
><mfrac><mrow 
><mi class="qopname"> exp</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo></mrow> 
      <mrow 
><mi 
>Z</mi></mrow></mfrac>      </mrow> 
<mrow 
><mfrac><mrow 
><mi class="qopname"> exp</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo></mrow>
      <mrow 
><mi 
>Z</mi></mrow></mfrac>      <mo 
class="MathClass-bin">+</mo> <msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>n</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></mfrac> <mo 
class="MathClass-rel">=</mo>        <mfrac><mrow 
><mi class="qopname">exp</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo></mrow> 
<mrow 
><mi class="qopname">exp</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">+</mo> <mi 
>Z</mi><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>n</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></mfrac>
</math></td><td class="eq-no">(5)</td></tr></table>
<!--l. 305--><p class="indent" >   and </p><table class="equation-star"><tr><td>
<!--l. 306--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                                 <mfrac><mrow 
><mi class="qopname"> exp</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><msup><mrow 
><mi 
>𝜃</mi></mrow><mrow 
><mo 
class="MathClass-bin">∗</mo></mrow></msup 
></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo></mrow>
      <mrow 
><msup><mrow 
><mi 
>Z</mi></mrow><mrow 
><mo 
class="MathClass-bin">∗</mo></mrow></msup 
></mrow></mfrac>     <mo 
class="MathClass-rel">≃</mo> <mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo>
</math></td></tr></table>
<!--l. 309--><p class="indent" >   where <!--l. 309--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><msup><mrow 
><mi 
>𝜃</mi></mrow><mrow 
><mo 
class="MathClass-bin">∗</mo></mrow></msup 
></mrow></msub 
></math>
would be our trained energy model.
</p><!--l. 311--><p class="indent" >   With <!--l. 311--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>D</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></math> constructed
as in (<a 
href="#x1-6001r5">5<!--tex4ht:ref: eq:nce-d-theta --></a>), <!--l. 311--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>D</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
></math>’s
optimization objective becomes
</p><!--tex4ht:inline--><!--l. 316--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" ><mtable 
columnalign="left" class="align-star">
               <mtr><mtd 
columnalign="right" class="align-odd"></mtd>                 <mtd 
class="align-even"><munder class="msub"><mrow 
><mi class="qopname"> max</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo></mrow><mrow 
><mi 
>𝜃</mi><mo 
class="MathClass-punc">,</mo><mi 
>Z</mi></mrow></munder 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>x</mi><mo 
class="MathClass-rel">∼</mo><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></msub 
><mi class="qopname"> log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><msub><mrow 
><mi 
>D</mi></mrow><mrow 
><mi 
>𝜃</mi><mo 
class="MathClass-punc">,</mo><mi 
>Z</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">+</mo> <msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>x</mi><mo 
class="MathClass-rel">∼</mo><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>n</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></msub 
><mi class="qopname"> log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo 
class="MathClass-open">(</mo><mn>1</mn> <mo 
class="MathClass-bin">−</mo> <msub><mrow 
><mi 
>D</mi></mrow><mrow 
><mi 
>𝜃</mi><mo 
class="MathClass-punc">,</mo><mi 
>Z</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo><mspace width="2em"/></mtd>                                                       <mtd 
columnalign="right" class="align-label"></mtd>               <mtd 
class="align-label">
               <mspace width="2em"/></mtd></mtr><mtr><mtd 
columnalign="right" class="align-odd"> <mo 
class="MathClass-rel">=</mo></mtd>               <mtd 
class="align-even"><munder class="msub"><mrow 
><mi class="qopname">max</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo></mrow><mrow 
><mi 
>𝜃</mi><mo 
class="MathClass-punc">,</mo><mi 
>Z</mi></mrow></munder 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>x</mi><mo 
class="MathClass-rel">∼</mo><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></msub 
><mo 
class="MathClass-open">[</mo><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">−</mo><mi class="qopname"> log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo 
class="MathClass-open">(</mo><mi class="qopname">exp</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">+</mo> <mi 
>Z</mi><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>n</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">]</mo> <mo 
class="MathClass-bin">+</mo> <msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>x</mi><mo 
class="MathClass-rel">∼</mo><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>n</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></msub 
><mo 
class="MathClass-open">[</mo><mi class="qopname">log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo 
class="MathClass-open">(</mo><mi 
>Z</mi><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>n</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">−</mo><mi class="qopname"> log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo 
class="MathClass-open">(</mo><mi class="qopname">exp</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">+</mo> <mi 
>Z</mi><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>n</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">]</mo><mspace width="2em"/></mtd>               <mtd 
columnalign="right" class="align-label"></mtd>               <mtd 
class="align-label">
   <mspace width="2em"/></mtd></mtr></mtable></math>
<!--l. 319--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">3.4   </span> <a 
 id="x1-70003.4"></a>Flow Contrastive Estimation</h4>
<!--l. 321--><p class="noindent" >In theory, there are no requirements on the static noise distribution <!--l. 322--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>n</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math>
for NCE. In practice, the closer <!--l. 322--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>n</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math>
is to <!--l. 322--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>p</mi></math>
(but not identical), the more eﬀective NCE is. Flow Contrastive Estimation parameterizes
<!--l. 324--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>n</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math> as
<!--l. 324--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>ϕ</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></math> with a
normalizing ﬂow model because normalizing ﬂow models are easy to sample and give tractable PDF. The discriminator is now modeled as
</p><table class="equation-star"><tr><td>

<!--l. 327--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                           <msub><mrow 
><mi 
>D</mi></mrow><mrow 
><mi 
>𝜃</mi><mo 
class="MathClass-punc">,</mo><mi 
>Z</mi><mo 
class="MathClass-punc">,</mo><mi 
>ϕ</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-rel">=</mo>        <mfrac><mrow 
><mi class="qopname">exp</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo></mrow> 
<mrow 
><mi class="qopname">exp</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>𝜃</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">+</mo> <mi 
>Z</mi><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>ϕ</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></mfrac>
</math></td></tr></table>
<!--l. 330--><p class="indent" >   and the objective function is </p><table class="equation-star"><tr><td>
<!--l. 331--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                              <munder class="msub"><mrow 
><mi class="qopname">max</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo></mrow><mrow 
><mi 
>𝜃</mi><mo 
class="MathClass-punc">,</mo><mi 
>Z</mi></mrow></munder 
><munder class="msub"><mrow 
><mi class="qopname"> min</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo></mrow><mrow 
><mi 
>ϕ</mi></mrow></munder 
><msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>x</mi><mo 
class="MathClass-rel">∼</mo><mi 
>p</mi><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></msub 
><mi class="qopname"> log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo 
class="MathClass-open">(</mo><msub><mrow 
><mi 
>D</mi></mrow><mrow 
><mi 
>𝜃</mi><mo 
class="MathClass-punc">,</mo><mi 
>Z</mi><mo 
class="MathClass-punc">,</mo><mi 
>ϕ</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo> <mo 
class="MathClass-bin">+</mo> <msub><mrow 
><mi 
>E</mi></mrow><mrow 
><mi 
>x</mi><mo 
class="MathClass-rel">∼</mo><msub><mrow 
><mi 
>p</mi></mrow><mrow 
><mi 
>ϕ</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo></mrow></msub 
><mi class="qopname"> log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo 
class="MathClass-open">(</mo><mn>1</mn> <mo 
class="MathClass-bin">−</mo> <msub><mrow 
><mi 
>D</mi></mrow><mrow 
><mi 
>𝜃</mi><mo 
class="MathClass-punc">,</mo><mi 
>Z</mi><mo 
class="MathClass-punc">,</mo><mi 
>ϕ</mi></mrow></msub 
><mo 
class="MathClass-open">(</mo><mi 
>x</mi><mo 
class="MathClass-close">)</mo><mo 
class="MathClass-close">)</mo>
</math></td></tr></table>
    
</body> 
</html>


